use std::{
    fs,
    path::{Path, PathBuf},
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let protoc_path: PathBuf = protoc_bin_vendored::protoc_bin_path()?;
    unsafe {
        std::env::set_var("PROTOC", protoc_path);
    }

    let proto_root = "proto/xray";
    let protos = [
        "proto/xray/app/proxyman/config.proto",
        "proto/xray/app/proxyman/command/command.proto",
        "proto/xray/app/stats/command/command.proto",
        "proto/xray/common/net/address.proto",
        "proto/xray/common/net/network.proto",
        "proto/xray/common/net/port.proto",
        "proto/xray/common/protocol/user.proto",
        "proto/xray/common/serial/typed_message.proto",
        "proto/xray/core/config.proto",
        "proto/xray/proxy/shadowsocks_2022/config.proto",
        "proto/xray/proxy/vless/account.proto",
        "proto/xray/proxy/vless/inbound/config.proto",
        "proto/xray/transport/internet/config.proto",
        "proto/xray/transport/internet/reality/config.proto",
        "proto/xray/transport/internet/tcp/config.proto",
    ];

    for proto in protos {
        println!("cargo:rerun-if-changed={proto}");
    }

    tonic_prost_build::configure()
        .build_client(true)
        .build_server(true)
        .compile_protos(&protos, &[proto_root])?;

    embed_web_dist()?;

    Ok(())
}

fn embed_web_dist() -> Result<(), Box<dyn std::error::Error>> {
    let manifest_dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR")?);
    let dist_dir = manifest_dir.join("web").join("dist");

    // Ensure cargo rebuilds when web assets change.
    println!("cargo:rerun-if-changed=web/dist");
    println!("cargo:rerun-if-changed=web/dist/assets");

    let index_html = dist_dir.join("index.html");
    if !index_html.is_file() {
        return Err(format!(
            "missing web/dist/index.html at {index_html:?}; run `cd web && bun run build`"
        )
        .into());
    }

    let mut files: Vec<PathBuf> = Vec::new();
    collect_files_recursively(&dist_dir, &mut files)?;
    files.sort();

    let mut entries: Vec<(String, String)> = Vec::new();
    for file in files {
        let rel = file.strip_prefix(&dist_dir)?;
        if rel.as_os_str().is_empty() {
            continue;
        }

        let rel_str = rel
            .to_string_lossy()
            .replace('\\', "/")
            .trim_start_matches('/')
            .to_string();
        let include_suffix = format!("/web/dist/{rel_str}");

        println!("cargo:rerun-if-changed=web/dist/{rel_str}");
        entries.push((rel_str, include_suffix));
    }

    let out_dir = PathBuf::from(std::env::var("OUT_DIR")?);
    let out_file = out_dir.join("embedded_web_assets.rs");

    let mut src = String::new();
    src.push_str("// @generated by build.rs; do not edit.\n");
    src.push_str("#[allow(clippy::all)]\n");
    src.push_str("pub fn get(path: &str) -> Option<&'static [u8]> {\n");
    src.push_str("    match path {\n");
    for (rel_path, include_suffix) in entries {
        src.push_str(&format!(
            "        {rel_path:?} => Some(&include_bytes!(concat!(env!(\"CARGO_MANIFEST_DIR\"), {include_suffix:?}))[..]),\n"
        ));
    }
    src.push_str("        _ => None,\n");
    src.push_str("    }\n");
    src.push_str("}\n");

    fs::write(out_file, src)?;
    Ok(())
}

fn collect_files_recursively(dir: &Path, out: &mut Vec<PathBuf>) -> Result<(), std::io::Error> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        let meta = entry.metadata()?;
        if meta.is_dir() {
            collect_files_recursively(&path, out)?;
        } else if meta.is_file() {
            out.push(path);
        }
    }
    Ok(())
}
